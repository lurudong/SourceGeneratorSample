

using Microsoft.CodeAnalysis;

namespace SourceGeneratorSample.Base
{

    /// <summary>
    /// 生成一个源代生成器，生成一个类型，自带一个打招呼的方法。
    /// </summary>
    /// <remarks>
    ///  提示 --可以配置隐藏起来，显示还是不显示
    /// </remarks>
    [Generator(LanguageNames.CSharp)]
    public sealed class GreetingSourceGenerator : ISourceGenerator
    {
        ///<inheritodc/>  //文档注释，鼠标放上名字上就会提示

        /// <summary>
        /// 生成源码
        /// </summary>
        /// <param name="context"></param>
        public void Execute(GeneratorExecutionContext context)
        {
            // 找到mian方法
            var mainMethod = context.Compilation.GetEntryPoint(context.CancellationToken);
            string source = $@"
// 告知编译器，该文件由源代码生成器的或别的手段生成产生的代码。
// 这样可以防止编译器对这个代码段进行代码分析，避免不必要的编译器警告或普通信息提示。
// <auto-generated/>  
// 启用可空性检查，“可空引用类型的”的单文件启用写法。
#nullable enable
[global::System.Runtime.CompilerServices.CompilerGeneratedAttribute]
[global::System.CodeDom.Compiler.GeneratedCodeAttribute(""{nameof(GreetingSourceGenerator)}"",""1.0"")]
public static  class Greeting
    {{
      public  static  void SayHelloTo(string name) =>
            global::System.Console.WriteLine($""Generator says: '{{name}}'"");
    }}
";
            //生成源码
            context.AddSource("Greeting.g.cs", source);
        }

        ///<inheritodc/> 
        /// <summary>
        /// 初始化，
        /// </summary>
        /// <param name="context"></param>
        public void Initialize(GeneratorInitializationContext context)
        {

        }
    }


}

