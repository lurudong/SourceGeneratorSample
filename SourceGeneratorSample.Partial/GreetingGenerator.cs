using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Linq;

namespace SourceGeneratorSample.Partial
{
    /// <summary>
    /// 生成一个源代生成器，生成一个类型，自带一个打招呼的方法。
    /// </summary>
    /// <remarks>
    ///  提示 --可以配置隐藏起来，显示还是不显示
    /// </remarks>
    [Generator(LanguageNames.CSharp)]
    public sealed class GreetingGenerator : ISourceGenerator
    {
        ///<inheritodc/>   //文档注释，鼠标放上名字上就会提示

        /// <summary>
        /// 生成源码
        /// </summary>
        /// <param name="context"></param>
        public void Execute(GeneratorExecutionContext context)
        {
            var syntaxReceiver = (SyntaxReceiver)context.SyntaxReceiver!;

            if (syntaxReceiver.MethodDeclarationSyntax is not { } methodSyntax)
            {
                return;
            }

            //外层节点，先辈
            var type = methodSyntax.Ancestors().OfType<TypeDeclarationSyntax>().First();
            var typeName = type.Identifier.ValueText;
            string source = $@"
// 告知编译器，该文件由源代码生成器的或别的手段生成产生的代码。
// 这样可以防止编译器对这个代码段进行代码分析，避免不必要的编译器警告或普通信息提示。
// <auto-generated/>  
// 启用可空性检查，“可空引用类型的”的单文件启用写法。
#nullable enable

//----------------------------------------------
 partial class  {typeName}
{{

    public static partial void SayHelloTo(string name)
    {{
          global::System.Console.WriteLine($""GreetingUsePartialClass: '{{name}}'"");
    }}
}}
";
            //生成源码
            context.AddSource($"{typeName}.g.cs", source);
        }

        ///<inheritodc/> 
        /// <summary>
        /// 初始化，
        /// </summary>
        /// <param name="context"></param>
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(static () => new SyntaxReceiver());

            //if (!Debugger.IsAttached)
            //{
            //    Debugger.Launch();
            //}
        }
    }

}


/// <summary>
/// 提供一个语法搜索类型，这个类型用于寻找主要项目的里指定语法满足多条件的部分
/// </summary>
file sealed class SyntaxReceiver : ISyntaxReceiver
{
    /// <summary>
    /// 表示一个方法的语法节点<c>SayHelloTo</c>方法
    /// 它必须是一个静态方法，而且标记了<see langword="partial"/> 关键字
    /// </summary>
    public MethodDeclarationSyntax? MethodDeclarationSyntax { get; private set; }
    //<inheritodc/> 
    public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
    {

        //不是类型声明
        //Modifiers 修饰符
        if (syntaxNode is not TypeDeclarationSyntax  //它必须是一个类型的定义
            { Modifiers: var modifiers and not [] })
        {
            return;
        }

        //不包含Partial 关键字
        if (!modifiers.Any(SyntaxKind.PartialKeyword))
        {
            return;
        }

        // 继续校验，这里需要判定它的子节点（类型嵌套内部的这些成员）
        foreach (var childNode in syntaxNode.ChildNodes())
        {

            if (childNode is not MethodDeclarationSyntax  //方法定义
                {
                    Identifier: { ValueText: "SayHelloTo" },

                    //void
                    ReturnType: PredefinedTypeSyntax
                    {
                        Keyword: { RawKind: (int)SyntaxKind.VoidKeyword }
                    },
                    //该方法还需要额外的修饰符(一会儿要用来判断partial关键字)。
                    Modifiers: var childNodeModifiers and not []


                } poossibleMethodDeclarationSyntax)
            {
                continue;
            }

            if (!childNodeModifiers.Any(SyntaxKind.PartialKeyword))
            {
                continue;
            }

            if (MethodDeclarationSyntax is null)
            {
                MethodDeclarationSyntax = poossibleMethodDeclarationSyntax;
                return;
            }


        }

    }
}
