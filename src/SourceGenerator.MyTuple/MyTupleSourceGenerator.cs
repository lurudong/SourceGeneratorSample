using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;
using SourceGeneratorSample.Core;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace SourceGenerator.MyTuple;

/// <summary>
/// 生成一个组件类型
/// </summary>
[Generator(LanguageNames.CSharp)]
public class MyTupleSourceGenerator : ISourceGenerator
{
    /// <summary>
    /// 错误信息
    /// </summary>
    private static readonly DiagnosticDescriptor _rule = new DiagnosticDescriptor(
               id: "SG0000",
                      title: "本地配置文件错误",
                             messageFormat: "源代码生成成功，但本地配置文件有误。错误情况：{0}。",
                                    category: "SourceGenerator",
                                           DiagnosticSeverity.Warning,
                                                  isEnabledByDefault: true,
                                                  "源代码生成成功，但本地配置文件有误。",
                                                  null,
                                                  Array.Empty<string>());

    ///<inheritodc/> 
    public void Execute(GeneratorExecutionContext context)
    {
        //读取本地配置文件，用.txt表示
        var additionalFiles = context.AdditionalFiles;
        var maxCount = 8;
        if (additionalFiles is [{ Path: var path }])
        {
            var result = File.ReadAllText(path);
            var regex = new Regex("""\d+""");
            var mathch = regex.Match(result);
            if (!mathch.Success)
            {
                context.ReportDiagnostic(Diagnostic.Create(_rule, Location.None, "没有匹配到数字"));
                goto NextStep;
            }

            var v = regex.Match(result).Value;
            if (!int.TryParse(v, out var value))
            {
                context.ReportDiagnostic(Diagnostic.Create(_rule, Location.None, "数字过大"));
                goto NextStep;
            }

            if (value is not (>= 2 and <= 8))
            {
                context.ReportDiagnostic(Diagnostic.Create(_rule, Location.None, "输入的数字只能2-8之间"));
                goto NextStep;
            }

            maxCount = value;

        }
    NextStep:
        List<string> list = new(maxCount);

        for (int i = 2; i <= maxCount; i++)
        {
            var genericArgs = $"<{string.Join(", ", from index in Enumerable.Range(1, i) select $"T{index}")}>";
            var ctorArgs = string.Join(", ", from index in Enumerable.Range(1, i) select $"T{index} value{index}");
            var constrains = string.Join("\r\n\t",
                from index in Enumerable.Range(1, i)
                select
                $" where T{index} : global::System.Numerics.IEqualityOperators<T{index}, T{index}, bool> ");

            var properties = string.Join("\r\n\t",
                from index in Enumerable.Range(1, i)
                select
                $"public T{index} Value{index} {{ get; }} = value{index};");

            var comparison = string.Join(" && ",
                from index in Enumerable.Range(1, i)
                select
              $"left.Value{index} == right.Value{index}");

            list.Add(@$"
public readonly struct MyTuple{genericArgs}({ctorArgs}) :
    global::System.Numerics.IEqualityOperators<MyTuple{genericArgs}, MyTuple{genericArgs}, bool>
   {constrains}
{{


    {properties}

    public static bool operator ==(MyTuple{genericArgs} left, MyTuple{genericArgs} right)
    {{

        return  {comparison};
    }}

    public static bool operator !=(MyTuple{genericArgs} left, MyTuple{genericArgs} right)
    {{

        return !(left == right);
    }}
}}");
        }
        string text = @$"
       //<auto-generated/>  
       namespace System;

             {string.Join("\r\n\r\n", list)}
      ";

        //使用这个方式格式化代码，免得生成的格式太难看    
        string extensionTextFormatted = CSharpSyntaxTree.ParseText(text, new CSharpParseOptions(LanguageVersion.CSharp10)).GetRoot().NormalizeWhitespace().SyntaxTree.GetText().ToString();

        context.AddSource($"MyTuple{SourceGeneratorFileNameShortcut.MyTupleGenerator}", SourceText.From(extensionTextFormatted, Encoding.UTF8));

    }

    ///<inheritodc/> 
    public void Initialize(GeneratorInitializationContext context)
    {

    }
}

//public readonly struct MyTuple<T1, T2>(T1 value1, T2 value2) :
//    IEqualityOperators<MyTuple<T1, T2>, MyTuple<T1, T2>, bool>

//      where T1 : IEqualityOperators<T1, T1, bool>
//      where T2 : IEqualityOperators<T2, T2, bool>
//{

//    public T1 Value1 { get; } = value1;

//    public T2 Value2 { get; } = value2;

//    public static bool operator ==(MyTuple<T1, T2> left, MyTuple<T1, T2> right)
//    {

//        left.Value1 == right.Value1 && left.Value2 == right.Value2;
//    }

//    public static bool operator !=(MyTuple<T1, T2> left, MyTuple<T1, T2> right)
//    {

//        return !(left == right);
//    }
//}
