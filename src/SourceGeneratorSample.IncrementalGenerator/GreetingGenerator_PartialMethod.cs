using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using SourceGeneratorSample.Core;
using System.Linq;
using System.Threading;

namespace SourceGeneratorSample.IncrementalGenerator;

[Generator(LanguageNames.CSharp)]
public sealed class GreetingGenerator_PartialMethod : IIncrementalGenerator
{

    /// <inheritdoc>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        //if (!Debugger.IsAttached)
        //{
        //    Debugger.Launch();
        //}

        context.RegisterSourceOutput(
            context.SyntaxProvider.
            CreateSyntaxProvider(
                Condition,
                static (gsc, _) =>
                {

                    var node = (MethodDeclarationSyntax)gsc.Node;
                    return node;

                }), (spc, data) =>
                {

                    //Ancestors 祖先节点
                    var type = data.Ancestors().OfType<TypeDeclarationSyntax>().First();
                    var typeName = type.Identifier.ValueText;
                    string source = $@"
// <auto-generated/>  
namespace SourceGeneratorSample;
#nullable enable
 partial class  {typeName}
{{

    public static partial void SayHelloTo2(string name)
    {{
          global::System.Console.WriteLine($""GreetingUsePartialClass_IncrementalGenerator: '{{name}}'"");
    }}
}}
";
                    spc.AddSource($"{typeName}{SourceGeneratorFileNameShortcut.GreetingGenerator_PartialMethod_UseIncrementalGenerator}", source);
                });

    }

    private static bool Condition(SyntaxNode node, CancellationToken _)
    {

        if (node is not
            MethodDeclarationSyntax
            {
                Identifier: { ValueText: "SayHelloTo2" },
                Modifiers: var methodModifiers and not [],
                ReturnType: PredefinedTypeSyntax
                {
                    Keyword.RawKind: (int)SyntaxKind.VoidKeyword
                },
                TypeParameterList: null, //泛型参数
                ParameterList.Parameters:
                [
                    {
                        Type: PredefinedTypeSyntax
                        {
                            Keyword.RawKind: (int)SyntaxKind.StringKeyword,
                        }
                    }
                ],
                Parent: ClassDeclarationSyntax
                {
                    Modifiers: var typeModifiers and not [],

                }
            })
        {
            return false;
        }
        //不包含Partial 关键字
        if (!methodModifiers.Any(SyntaxKind.PartialKeyword)
            || !typeModifiers.Any(SyntaxKind.PartialKeyword))
        {
            return false;
        }

        if (!methodModifiers.Any(SyntaxKind.StaticKeyword))
        {
            return false;
        }
        return true;
    }
}